AND 연산자: 상위 4비트를 제외하고 하위 4비트를 가져올떄 00001111과 AND 연산 시키는 방식으로 사용

* AND 연산은 오버&캐리 플러그가 무조건 0(발생 안함) 그 외 사인&제로&파티 플러그는 연산 결과에 따라 나뉨

<img width="965" height="307" alt="image" src="https://github.com/user-attachments/assets/e59abf60-3394-4c05-9e40-f6c2ff0108a2" />

--------------------------------------------------

OR 연산자

* 캐리&오버 플러그는 항상 0으로 초기화(발생X) 그 와 사인&제로&파티 플러그는 연산 결과에 따


------------------------------------------------

XOR 연산자: 같으면 0, 다르면 1을 반환

* XOR 연산자는 같은 값 A에 값B를 두번 쓰면 값 A 원본으로 돌아옴

* 이러 한 특징을 살려 가장 기초적인 암호화코드에 쓰임
  
|  x |  y | (x \oplus y) | ((x \oplus y) \oplus y) |   결과  |
| -: | -: | :----------: | :---------------------: | :---: |
|  0 |  0 |       0      |            0            | (= x) |
|  0 |  1 |       1      |            0            | (= x) |
|  1 |  0 |       1      |            1            | (= x) |
|  1 |  1 |       0      |            1            | (= x) |

------------------------------------------------

Checking the Parity Flag

* XOR 0 명령을 사용하면 값을 변경하지 않고도 **패리티 플래그(Parity Flag)**를 확인할 수 있습니다.
* PF = 1 → 짝수 패리티 (even)
* PF = 0 → 홀수 패리티 (odd)

mov al, 10110101b       ; 1의 개수 = 5 → odd parity
xor al, 0               ; PF clear (odd)

mov al, 11001100b       ; 1의 개수 = 4 → even parity
xor al, 0               ; PF set (even)

mov ax, 64C1h           ; AX = 0110 0100 1100 0001
xor ah, al              ; PF set (even)

| 연산                           | 비트 패턴               | 1의 개수 | 패리티 결과    | PF 상태     |
| ---------------------------- | ------------------- | ----- | --------- | --------- |
| `mov al, 10110101b`          | 10110101            | 5     | 홀수 (Odd)  | Clear (0) |
| `mov al, 11001100b`          | 11001100            | 4     | 짝수 (Even) | Set (1)   |
| `mov ax, 64C1h / xor ah, al` | 0110 0100 1100 0001 | 짝수    | Even      | Set (1)   |


----------------------------------------------------

NOT


----------------------------------------------------

TEST

-----------------------------------------------------

CMP: 비교 수행 명령 -> 목적지(destination) 피연산자에서 소스(source) 피연산자를 뺀 결과를 가정하여
플래그(Flags)를 변경

* 실제로는 뺄셈이 수행되지 않으며, 두 피연산자의 값은 변하지 않는다.
* 뺴기(-)를 이용해 비교를 수행하기 떄문에 리턴값은 양수(+), 같음(==), 음수(-)를 반환한다 이는 다른 고급언어의 컴페어 함수도 동일한 메커니즘을 사용함

----------------------------------------------------

Example1~4

|       예제      | 코드 요약                                                         | 연산 결과 / 레지스터 상태                 | 관련 조건                             | 점프 결과                               | 해설                                    |
| :-----------: | :------------------------------------------------------------ | :------------------------------ | :-------------------------------- | :---------------------------------- | :------------------------------------ |
| **Example 1** | `mov edx, 0A523h`<br>`cmp edx, 0A523h`<br>`jne L5`<br>`je L1` | `edx - 0A523h = 0` → **ZF = 1** | `JE` → ZF=1일 때<br>`JNE` → ZF=0일 때 | `JNE`: ❌ not taken<br>`JE`: ✅ taken | `CMP` 결과 0 → ZF=1 → 두 값 같음<br>`JE` 실행 |
| **Example 2** | `mov bx, 1234h`<br>`sub bx, 1234h`<br>`jne L5`<br>`je L1`     | `bx - bx = 0` → **ZF = 1**      | `JE` → ZF=1일 때<br>`JNE` → ZF=0일 때 | `JNE`: ❌ not taken<br>`JE`: ✅ taken | `SUB` 결과 0 → ZF=1 → 두 값 같음<br>`JE` 실행 |
| **Example 3** | `mov cx, 0FFFFh`<br>`inc cx`<br>`jcxz L2`                     | `0FFFFh + 1 = 0000h` → **CX=0** | `JCXZ` → CX=0일 때                  | ✅ jump taken                        | `INC` 후 CX가 0 → `JCXZ` 조건 충족          |
| **Example 4** | `xor ecx, ecx`<br>`jecxz L2`                                  | `ECX XOR ECX = 0` → **ECX=0**   | `JECXZ` → ECX=0일 때                | ✅ jump taken                        | 자기 자신과 XOR → 항상 0<br>`JECXZ` 조건 충족    |

요약

CMP, SUB → 결과가 0이면 ZF=1 → JE 실행

INC, XOR → 결과 레지스터가 0이면 JCXZ / JECXZ 실행

Jxx 명령은 조건이 참일 때만 점프

-------------------------------------------------------


----------------------------------------------------------

COnditional Jumps 실행: Sequential Search of an Arrat
